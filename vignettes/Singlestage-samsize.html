<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Richard Valliant, Jill A. Dever, and Frauke Kreuter" />

<meta name="date" content="2020-08-03" />

<title>Sample Size Calculation in Single-stage Sampling</title>

<script>// Hide empty <a> tag within highlighted CodeBlock for screen reader accessibility (see https://github.com/jgm/pandoc/issues/6352#issuecomment-626106786) -->
// v0.0.1
// Written by JooYoung Seo (jooyoung@psu.edu) and Atsushi Yasumoto on June 1st, 2020.

document.addEventListener('DOMContentLoaded', function() {
  const codeList = document.getElementsByClassName("sourceCode");
  for (var i = 0; i < codeList.length; i++) {
    var linkList = codeList[i].getElementsByTagName('a');
    for (var j = 0; j < linkList.length; j++) {
      if (linkList[j].innerHTML === "") {
        linkList[j].setAttribute('aria-hidden', 'true');
      }
    }
  }
});
</script>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
code.sourceCode > span { display: inline-block; line-height: 1.25; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
code.sourceCode > span:empty { height: 1.2em; }
.sourceCode { overflow: visible; }
code.sourceCode { white-space: pre; position: relative; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
code.sourceCode { white-space: pre-wrap; }
code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Sample Size Calculation in Single-stage Sampling</h1>
<h4 class="author">Richard Valliant, Jill A. Dever, and Frauke Kreuter</h4>
<h4 class="date">2020-08-03</h4>



<script type="text/x-mathjax-config">
MathJax.Hub.Config({
  TeX: { equationNumbers: { autoNumber: "AMS" } }
});
</script>
<p>A basic issue in sample design is how many units should be selected at each stage in order to efficiently estimate population values. If strata are used, the number of units to allocate to each stratum must be determined. In this vignette, we review some basic techniques for sample size determination in single-stage samples using the package <code>PracTools</code> <span class="citation">(Valliant, Dever, and Kreuter 2019)</span> that contains specialized routines to facilitate the calculations, most of which are not found in other packages. We briefly summarize some of selection methods and associated formulas used in designing single-stage samples and describe the capabilities of <code>PracTools</code>. Technical background is in <span class="citation">Valliant, Dever, and Kreuter (2018)</span>, ch.Â 3. First, the package must be loaded with</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">library</span>(PracTools)</span></code></pre></div>
<p>Alternatively, <code>require(PracTools)</code> can be used.</p>
<p>Complex samples can involve any or all of stratification, clustering, multistage sampling, and sampling with varying probabilities. Many texts cover these topics, including <span class="citation">Cochran (1977)</span>, <span class="citation">Lohr (1999)</span>, <span class="citation">SÃ¤rndal, Swensson, and Wretman (1992)</span>, and <span class="citation">Valliant, Dever, and Kreuter (2018)</span>. Here we discuss single-stage designs with and without stratification and formulas that are needed for determining sample allocations. The <code>PracTools</code> package will not select samples, but the R <code>sampling</code> package <span class="citation">(TillÃ© and Matei 2016)</span> will select almost all the types used in practice.</p>
<div id="simple-random-sampling" class="section level2">
<h2>Simple Random Sampling</h2>
<p>Simple random sampling without replacement (<em>srswor</em>) is a method of probability sampling in which all samples of a given size <span class="math inline">\(n\)</span> have the same probability of selection. The function <code>sample</code> in R base <span class="citation">(R Core Team 2020)</span> will select simple random samples either with or without replacement. One way of determining an <em>srswor</em> sample size is to specify that a population value <span class="math inline">\(\small \theta\)</span> be estimated with a certain coefficient of variation (<em>CV</em>) which is defined as the ratio of the standard error of the estimator, <span class="math inline">\(\small \hat{\theta}\)</span>, to the value of the parameter: <span class="math inline">\(\small CV(\hat{\theta}) = \sqrt{Var(\hat{\theta})}/\theta\)</span>. For example, suppose that <span class="math inline">\(\small y_{k}\)</span> is a value associated with element <span class="math inline">\(\small k\)</span>, <span class="math inline">\(\small U\)</span> denotes the set of all elements in the universe, <span class="math inline">\(\small N\)</span> is the number of elements in the population, and the population parameter to be estimated is the mean, <span class="math inline">\(\small \bar{y}_{U} = \sum_{k \in U}y_{k}/N\)</span>. With a simple random sample, this can be estimated by the sample mean, <span class="math inline">\(\small \bar{y}_{s} = \sum_{k \in s}y_{k}/n\)</span>, where <span class="math inline">\(\small s\)</span> is the set of sample elements and <span class="math inline">\(\small n\)</span> is the sample size. Setting the required <span class="math inline">\(\small CV\)</span> of <span class="math inline">\(\small \bar{y}_{s}\)</span> to some desired value <span class="math inline">\(\small CV_{0}\)</span> in an <em>srswor</em> leads to a sample size of <span class="math display">\[\small n=\frac{\frac{S_U^{2}}{\bar{y}_{U}^{2}}}{CV_{0}^{2} +\frac{S_U^{2}}{N\bar{y}_{U}^{2}}}\]</span></p>
<p>The R function, <code>nCont</code>, will compute a sample size using either a target <span class="math inline">\(\small CV_{0}\)</span> or a target variance, <span class="math inline">\(\small V_{0}\)</span>, of <span class="math inline">\(\small \bar{y}_s\)</span> as input. The parameters used by the function are shown below and are described in the help page for the function:</p>
<pre><code>    nCont(CV0=NULL, V0=NULL, S2=NULL, ybarU=NULL, N=Inf, CVpop=NULL)</code></pre>
<ul>
<li><strong>Example 1: Sample size for a target CV.</strong> Suppose that we estimate from a previous survey that the population CV of some variable is 2.0. If the population is extremely large and <code>CV0</code> (the target CV ) is set to 0.05, then the call to the R function is <code>nCont(CV0 = 0.05, CVpop = 2)</code>. The resulting sample size is 1,600. If the population size is <em>N</em> = 500, then <code>nCont(CV0 = 0.05,CVpop = 2, N = 500)</code> results in a sample size of 381 after rounding. The finite population correction (<em>fpc</em>) factor has a substantial effect in the latter case.</li>
</ul>
<p>The function <code>nProp</code> will perform the same computation for estimated proportions.</p>
<ul>
<li><strong>Example 2: Sample sizes for a vector of target CVs.</strong> Often it will be useful to show a client the sample sizes for a series of precision targets. This will be especially true when the budget is uncertain and a researcher would like to think about options. We can ask for the sample sizes for a vector of values of <code>CV0</code> from 0.01 to 0.21 in increments of 0.02 with:</li>
</ul>
<pre><code>    ceiling(nCont(CV0 = seq(0.01, 0.21, 0.02), CVpop=2))
    [1] 40000  4445  1600   817   494   331   237   178   139   111    91</code></pre>
<p><code>ncont</code> returns unrounded sample sizes having quite a few decimal places; <code>ceiling</code> rounds to the next highest integer.</p>
<div id="using-a-margin-of-error-to-find-sample-sizes" class="section level3">
<h3>Using a margin of error to find sample sizes</h3>
<p>Many investigators prefer to think of setting a tolerance for how close the estimate should be to the population value. If the tolerance, sometimes called the <em>margin of error</em> (MOE), is <span class="math inline">\(\small e\)</span> and the goal is to be within <span class="math inline">\(\small e\)</span> of the population mean with probability <span class="math inline">\(\small 1-\alpha\)</span>, this translates to <span class="math display">\[\begin{equation}
\small Pr \left(\left|\bar{y}_{s} -\bar{y}_{U} \right|\le e\right)=1-\alpha.
\end{equation}\]</span> This is equivalent to setting the half-width of a <span class="math inline">\(\small 100\left(1-\alpha \right)\)</span> two-sided confidence interval (CI) to <span class="math inline">\(\small e=z_{1-\alpha\left/2\right.} \sqrt{V\left(\bar{y}_{s} \right)}\)</span>, assuming that <span class="math inline">\(\small \bar{y}_{s}\)</span> can be treated as being normally distributed. The term <span class="math inline">\(\small z_{1-\alpha\left/2\right.}\)</span> is the <span class="math inline">\(\small 100\left(1-\alpha\left/2\right. \right)\)</span> percentile of the standard normal distribution, i.e., the point with <span class="math inline">\(\small 1-\alpha\left/2\right.\)</span> of the area to its left. On the other hand, if we require <span class="math display">\[\begin{equation}
   \small Pr \left(\left|\frac{\bar{y}_{s} -\bar{y}_{U}}{\bar{y}_{U}} \right|\le e\right)=1-\alpha, \end{equation}\]</span></p>
<p>this corresponds to setting <span class="math inline">\(\small e=z_{1-\alpha\left/2\right. }CV\left(\bar{y}_{s}\right)\)</span>. If we set the MOE in (1) to <span class="math inline">\(\small e_{0}\)</span>, then the above equation can be manipulated to give the required sample size as</p>
<p><span class="math display">\[\begin{equation}
  \small n=\frac{z_{1-\alpha\left/2\right.}^{2} S_U^{2}}{e_{0}^{2}+z_{1-\alpha\left/2\right.}^{2} S_U^{2}\left/N\right.}.
\end{equation}\]</span></p>
<p>Similarly, if the MOE in (2) is set to <span class="math inline">\(\small e_{0}\)</span>, we obtain <span class="math display">\[\begin{equation}
   \small n=\frac{z_{1-\alpha\left/2\right.}^{2} S_U^{2}\left/ \bar{y}_{U}^{2}\right.}{e_{0}^{2} +z_{1-\alpha \left/2\right.}^{2} S_U^{2}\left/ \left(N\bar{y}_{U}^{2} \right)\right.}
\end{equation}\]</span> The functions <code>nContMoe</code> and <code>nPropMoe</code> will make the sample size calculations based on MOEs for continuous variables and for proportions.</p>
<ul>
<li><strong>Example 3: Sample sizes for proportions based on an MOE.</strong> Suppose that we want to estimate a proportion for a characteristic where an advance estimate is <span class="math inline">\(\small p_{U} =0.5\)</span>. The MOE is to be <span class="math inline">\(\small e\)</span> when <span class="math inline">\(\small \alpha =0.05\)</span>. In other words, the sample should be large enough that a normal-approximation 95% confidence interval should be <span class="math inline">\(\small 0.50\pm e\)</span> as implied by (1). For example, if <span class="math inline">\(\small e=0.03\)</span> and the estimated proportion were actually 0.5, we want the confidence interval to be <span class="math inline">\(\small 0.50\pm 0.03=\left[0.47,0.53\right]\)</span>. The sample size is highly dependent on the width of the confidence interval as seen in the following table. Sample sizes are evaluated using the formula given in (3) with <span class="math inline">\(\small S_U^2 = Np_U(1-p_U)/(N-1)\)</span>, <span class="math inline">\(\small p_{U} =0.5\)</span> and <span class="math inline">\(\small z_{0.975} =1.96\)</span>. The command to generate the sample sizes listed in the table below is</li>
</ul>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a>    <span class="kw">ceiling</span>(<span class="kw">nPropMoe</span>(<span class="dt">moe.sw=</span><span class="dv">1</span>, <span class="dt">e=</span><span class="kw">seq</span>(<span class="fl">0.01</span>,<span class="fl">0.08</span>,<span class="fl">0.01</span>), <span class="dt">alpha=</span><span class="fl">0.05</span>, <span class="dt">pU=</span><span class="fl">0.5</span>))</span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="co">#&gt; [1] 9604 2401 1068  601  385  267  196  151</span></span></code></pre></div>
<table>
<thead>
<tr class="header">
<th align="right"><span class="math inline">\(e\)</span></th>
<th align="right"><span class="math inline">\(n\)</span></th>
<th align="right"></th>
<th align="right"><span class="math inline">\(e\)</span></th>
<th align="right"><span class="math inline">\(n\)</span></th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="right">0.01</td>
<td align="right">9,604</td>
<td align="right"></td>
<td align="right">0.05</td>
<td align="right">385</td>
</tr>
<tr class="even">
<td align="right">0.02</td>
<td align="right">2,401</td>
<td align="right"></td>
<td align="right">0.06</td>
<td align="right">267</td>
</tr>
<tr class="odd">
<td align="right">0.03</td>
<td align="right">1,068</td>
<td align="right"></td>
<td align="right">0.07</td>
<td align="right">196</td>
</tr>
<tr class="even">
<td align="right">0.04</td>
<td align="right">601</td>
<td align="right"></td>
<td align="right">0.08</td>
<td align="right">151</td>
</tr>
</tbody>
</table>
<p>The parameter <code>moe.sw=1</code> says to compute the sample size based on (3). <code>moe.sw=2</code> would use the MOE relative to <span class="math inline">\(\small \bar{y}_U\)</span> in (4).</p>
</div>
</div>
<div id="stratified-simple-random-sampling" class="section level2">
<h2>Stratified Simple Random Sampling</h2>
<p>Simple random samples are rare in practice for several reasons. Most surveys have multiple variables and domains for which estimates are desired. Selecting a simple random sample runs the risk that one or more important domains will be poorly represented or omitted entirely. In addition, variances of survey estimates often can be reduced by using a design that is not <em>srswor</em>.</p>
<p>A design that remedies some of the problems noted for an <em>srswor</em> is referred to as stratified simple random sampling (without replacement) or <em>stsrswor</em>. As the name indicates, an <em>srswor</em> design is administered within each design stratum. Strata are defined with one or more variables known for <em>all</em> units and partition the entire population into mutually exclusive groups of units. We might, for example, divide a population of business establishments into retail trade, wholesale trade, services, manufacturing, and other sectors. A household population could be divided into geographic regionsânorth, south, east, and west. For an <em>stsrswor</em>, we define the following terms:</p>
<p><span class="math inline">\(\small N_{h}\)</span> = the known number of units in the population in stratum <em>h</em> (<span class="math inline">\(\small h=1,2,\ldots ,H\)</span>)</p>
<p><span class="math inline">\(\small n_{h}\)</span> = the size of the <em>srswor</em> selected in stratum <em>h</em></p>
<p><span class="math inline">\(\small y_{hi}\)</span> = the value of the <em>y</em> variable for unit <em>i</em> in stratum <em>h</em></p>
<p><span class="math inline">\(\small S_{Uh}^{2}=\sum_{i=1}^{N_{h}}\left(y_{hi}-\bar{y}_{U_h}\right)^{2}\left/ \left(N_{h} -1\right)\right.\)</span>, the population variance in stratum <em>h</em></p>
<p><span class="math inline">\(\small U_{h}\)</span> = set of all units in the population from stratum <em>h</em></p>
<p><span class="math inline">\(\small s_{h}\)</span> = set of <span class="math inline">\(\small n_{h}\)</span> sample units from stratum <em>h</em></p>
<p><span class="math inline">\(\small c_h\)</span> = cost per sample unit in stratum <em>h</em></p>
<p>The population mean of <em>y</em> is <span class="math inline">\(\small \bar{y}_{U} =\sum_{h=1}^{H}W_{h}\bar{y}_{U_h}\)</span>, where <span class="math inline">\(\small W_{h}=N_{h}\left/ N\right.\)</span> and <span class="math inline">\(\small \bar{y}_{U_h}\)</span> is the population mean in stratum <em>h</em>. The sample estimator of <span class="math inline">\(\small \bar{y}_{U}\)</span> based on an <em>stsrswor</em> is <span class="math display">\[\begin{equation} 
   \small \bar{y}_{st} =\sum_{h=1}^{H}W_{h} \bar{y}_{s_h}, \notag
\end{equation}\]</span> where <span class="math inline">\(\small \bar{y}_{s_h} =\sum_{i\in s_{h}}y_{hi}\left/n_{h}\right.\)</span>. The population sampling variance of the stratified estimator of the mean is <span class="math display">\[\begin{equation} 
\small Var\left(\bar{y}_{st}\right) = \sum_{h=1}^{H}W_{h}^{2} \frac{1-f_{h}}{n_{h}} S_{Uh}^{2}, \notag
\end{equation}\]</span> where <span class="math inline">\(\small f_{h} = n_{h}\left/N_{h}\right.\)</span>. The total cost of the sample is <span class="math display">\[\small C = \sum_{h=1}^{H} c_h n_h.\]</span></p>
<p>There are various ways of allocating the sample to the strata, including:</p>
<ol style="list-style-type: decimal">
<li><p>Proportional to the <span class="math inline">\(\small N_h\)</span> population counts</p></li>
<li><p>Equal allocation (all <span class="math inline">\(\small n_h\)</span> the same)</p></li>
<li><p>Cost-constrained optimal in which the allocation minimizes the variance of <span class="math inline">\(\small \bar{y}_{st}\)</span> subject to a fixed budget</p></li>
<li><p>Variance-constrained optimal in which the allocation minimizes the total cost subject to a fixed variance target for <span class="math inline">\(\small \bar{y}_{st}\)</span></p></li>
<li><p>Neyman allocation, which minimizes the variance of the estimated mean disregarding the <span class="math inline">\(\small c_h\)</span> costs</p></li>
</ol>
<p>The R function, <code>strAlloc</code>, will compute the proportional, Neyman, cost-constrained, and variance-constrained allocations. The parameters accepted by the function are shown below.</p>
<pre><code>   n.tot = fixed total sample size 
   Nh = vector of pop stratum sizes or pop stratum proportions (required parameter)
   Sh = stratum unit standard deviations, required unless alloc = &quot;prop&quot; 
   cost = total variable cost 
   ch = vector of costs per unit in strata
   V0 = fixed variance target for estimated mean 
   CV0 = fixed CV target for estimated mean 
   ybarU = pop mean of y  
   alloc = type of allocation, must be one of &quot;prop&quot;, &quot;neyman&quot;, &quot;totcost&quot;, &quot;totvar&quot;</code></pre>
<p>If the stratum standard deviations are unknown (as would usually be the case), estimates can be used.</p>
<p>The parameters can only be used in certain combinations, which are checked at the beginning of the function. Basically, given an allocation, only the parameters required for the allocation are allowed and no more. For example, the Neyman allocation requires <code>Nh</code>, <code>Sh</code>, and <code>n.tot</code>. The function returns a list with three componentsâthe allocation type, the vector of sample sizes, and the vector of sample proportions allocated to each stratum. Three examples of allocations are Neyman, cost constrained, and variance constrained (via a target CV):</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1"></a><span class="co"># Neyman allocation</span></span>
<span id="cb6-2"><a href="#cb6-2"></a>Nh &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">215</span>, <span class="dv">65</span>, <span class="dv">252</span>, <span class="dv">50</span>, <span class="dv">149</span>, <span class="dv">144</span>)</span>
<span id="cb6-3"><a href="#cb6-3"></a>Sh &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">26787207</span>, <span class="dv">10645109</span>, <span class="dv">6909676</span>, <span class="dv">11085034</span>, <span class="dv">9817762</span>, <span class="dv">44553355</span>)</span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="kw">strAlloc</span>(<span class="dt">n.tot =</span> <span class="dv">100</span>, <span class="dt">Nh =</span> Nh, <span class="dt">Sh =</span> Sh, <span class="dt">alloc =</span> <span class="st">&quot;neyman&quot;</span>)</span>
<span id="cb6-5"><a href="#cb6-5"></a><span class="co">#&gt; </span></span>
<span id="cb6-6"><a href="#cb6-6"></a><span class="co">#&gt;      </span></span>
<span id="cb6-7"><a href="#cb6-7"></a><span class="co">#&gt; </span></span>
<span id="cb6-8"><a href="#cb6-8"></a><span class="co">#&gt;                       allocation = neyman</span></span>
<span id="cb6-9"><a href="#cb6-9"></a><span class="co">#&gt;                               Nh = 215, 65, 252, 50, 149, 144</span></span>
<span id="cb6-10"><a href="#cb6-10"></a><span class="co">#&gt;                               Sh = 26787207, 10645109, 6909676, 11085034, 9817762, 44553355</span></span>
<span id="cb6-11"><a href="#cb6-11"></a><span class="co">#&gt;                               nh = 34.641683, 4.161947, 10.473487, 3.333804, 8.798970, 38.590108</span></span>
<span id="cb6-12"><a href="#cb6-12"></a><span class="co">#&gt;                             nh/n = 0.34641683, 0.04161947, 0.10473487, 0.03333804, 0.08798970, 0.38590108</span></span>
<span id="cb6-13"><a href="#cb6-13"></a><span class="co">#&gt; anticipated SE of estimated mean = 1727173</span></span>
<span id="cb6-14"><a href="#cb6-14"></a></span>
<span id="cb6-15"><a href="#cb6-15"></a><span class="co"># cost constrained allocation</span></span>
<span id="cb6-16"><a href="#cb6-16"></a>ch &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="dv">1400</span>, <span class="dv">200</span>, <span class="dv">300</span>, <span class="dv">600</span>, <span class="dv">450</span>, <span class="dv">1000</span>)</span>
<span id="cb6-17"><a href="#cb6-17"></a><span class="kw">strAlloc</span>(<span class="dt">Nh =</span> Nh, <span class="dt">Sh =</span> Sh, <span class="dt">cost =</span> <span class="dv">100000</span>, <span class="dt">ch =</span> ch, <span class="dt">alloc =</span> <span class="st">&quot;totcost&quot;</span>)</span>
<span id="cb6-18"><a href="#cb6-18"></a><span class="co">#&gt; </span></span>
<span id="cb6-19"><a href="#cb6-19"></a><span class="co">#&gt;      </span></span>
<span id="cb6-20"><a href="#cb6-20"></a><span class="co">#&gt; </span></span>
<span id="cb6-21"><a href="#cb6-21"></a><span class="co">#&gt;                       allocation = totcost</span></span>
<span id="cb6-22"><a href="#cb6-22"></a><span class="co">#&gt;                               Nh = 215, 65, 252, 50, 149, 144</span></span>
<span id="cb6-23"><a href="#cb6-23"></a><span class="co">#&gt;                               Sh = 26787207, 10645109, 6909676, 11085034, 9817762, 44553355</span></span>
<span id="cb6-24"><a href="#cb6-24"></a><span class="co">#&gt;                               nh = 30.605403, 9.728474, 19.989127, 4.499121, 13.711619, 40.340301</span></span>
<span id="cb6-25"><a href="#cb6-25"></a><span class="co">#&gt;                             nh/n = 0.2574608, 0.0818385, 0.1681538, 0.0378478, 0.1153458, 0.3393533</span></span>
<span id="cb6-26"><a href="#cb6-26"></a><span class="co">#&gt; anticipated SE of estimated mean = 1636053</span></span>
<span id="cb6-27"><a href="#cb6-27"></a></span>
<span id="cb6-28"><a href="#cb6-28"></a><span class="co"># allocation with CV target of 0.05</span></span>
<span id="cb6-29"><a href="#cb6-29"></a><span class="kw">strAlloc</span>(<span class="dt">Nh =</span> Nh, <span class="dt">Sh =</span> Sh, <span class="dt">CV0 =</span> <span class="fl">0.05</span>, <span class="dt">ch =</span> ch, <span class="dt">ybarU =</span> <span class="dv">11664181</span>, <span class="dt">alloc =</span> <span class="st">&quot;totvar&quot;</span>)</span>
<span id="cb6-30"><a href="#cb6-30"></a><span class="co">#&gt; </span></span>
<span id="cb6-31"><a href="#cb6-31"></a><span class="co">#&gt;      </span></span>
<span id="cb6-32"><a href="#cb6-32"></a><span class="co">#&gt; </span></span>
<span id="cb6-33"><a href="#cb6-33"></a><span class="co">#&gt;                       allocation = totvar</span></span>
<span id="cb6-34"><a href="#cb6-34"></a><span class="co">#&gt;                               Nh = 215, 65, 252, 50, 149, 144</span></span>
<span id="cb6-35"><a href="#cb6-35"></a><span class="co">#&gt;                               Sh = 26787207, 10645109, 6909676, 11085034, 9817762, 44553355</span></span>
<span id="cb6-36"><a href="#cb6-36"></a><span class="co">#&gt;                               nh = 104.54922, 33.23283, 68.28362, 15.36917, 46.83941, 137.80400</span></span>
<span id="cb6-37"><a href="#cb6-37"></a><span class="co">#&gt;                             nh/n = 0.2574608, 0.0818385, 0.1681538, 0.0378478, 0.1153458, 0.3393533</span></span>
<span id="cb6-38"><a href="#cb6-38"></a><span class="co">#&gt; anticipated SE of estimated mean = 583209.1</span></span></code></pre></div>
<p>The output of <code>strAlloc</code> is a list with components: <code>allocation</code> (the type of allocation), <code>Nh</code>, <code>Sh</code>, <code>nh</code>, <code>nh/n</code>, and <code>anticipated SE of estimated mean</code>. If the results are assigned to an object, e.g., <code>neyman &lt;- strAlloc(n.tot = 100, Nh = Nh, Sh = Sh, alloc = &quot;neyman&quot;)</code>, the components in the list can be accessed with syntax like <code>neyman$nh</code>.</p>
<p>There are many variations on how to allocate a sample to strata. In most practical applications, there are multiple variables for which estimates are needed. This complicates the allocation problem because each variable may have a different optimal allocation. This type of multicriteria problem can be solved using mathematical programming as discussed in <span class="citation">Valliant, Dever, and Kreuter (2018)</span>, ch.Â 5.</p>
</div>
<div id="probability-proportional-to-size-sampling" class="section level2">
<h2>Probability Proportional to Size Sampling</h2>
<p>Probability proportional to size (<em>pps</em>), single-stage sampling is used in situations where an auxiliary variable (i.e., a covariate) is available on the frame that is related to the variable(s) to be collected in a survey. For example, the number of employees in a business establishment one year ago is probably related to the number of employees the establishment has in the current time period.</p>
<p>The variance formula for an estimated mean in a <em>pps</em> sample selected without replacement is too complex to be useful in determining a sample size. Thus, a standard workaround is to use the with-replacement (<em>ppswr</em>) variance formula to calculate a sample size. The result may be somewhat larger than needed to hit a precision target, but if the sample is reduced by nonresponse, beginning with a larger sample is prudent anyway. The simplest estimator of the mean that is usually studied with <em>ppswr</em> sampling is called ``<em>p</em>-expanded with replacementââ or <em>pwr</em> (see <span class="citation">SÃ¤rndal, Swensson, and Wretman (1992)</span>, ch.2) and is defined as <span class="math display">\[\begin{equation}
   \small \hat{\bar{y}}_{\textit{pwr}} =\frac{1}{Nn} \sum_{i \in s}\frac{y_{i}}{p_{i}} \notag
\end{equation}\]</span> where <span class="math inline">\(\small p_i\)</span> is the probability that unit <span class="math inline">\(\small i\)</span> would be selected in a sample of size 1. The variance of <span class="math inline">\(\small \hat{\bar{y}}_{\textit{pwr}}\)</span> in <em>ppswr</em> sampling is <span class="math display">\[\begin{equation} \label{eq:vpwr}
    \small Var\left(\hat{\bar{y}}_{pwr} \right)=\frac{1}{N^{2} n} \sum_{U}p_{i} \left(\frac{y_{i}}{p_{i}} - t_U\right)^{2}  \equiv \frac{V_{1}}{N^{2}n}
\end{equation}\]</span> where <span class="math inline">\(\small t_U\)</span> is the population total of <span class="math inline">\(\small y\)</span>.</p>
<p>If the desired coefficient of variation is <span class="math inline">\(\small CV_{0}\)</span>, <span class="math inline">\(\small \eqref{eq:vpwr}\)</span> can be solved to give the sample size as <span class="math display">\[\begin{equation} \label{eq:n.pwr}
    \small n=\frac{V_{1}}{N^{2}} \frac{1}{\bar{y}_{U}^{2} CV_{0}^{2}}\;.
\end{equation}\]</span></p>
<div class="figure">
<img src="data:image/png;base64,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" alt />
<p class="caption">Figure 1. Plot of expenditures vs.Â beds in hospital population</p>
</div>
<ul>
<li><strong>Example 4: Sample size in a <em>pps</em> sample.</strong> We use <code>smho.N874</code>, which is one of the example populations in the <code>PracTools</code> package, to illustrate a <em>pps</em> sample size calculation. Figure 1 plots annual expenditures per hospital versus number of beds for the 670 hospitals that have inpatient beds. Although the relationship is fairly diffuse, the correlation of beds and expenditures is 0.70 so that <em>pps</em> sampling with beds as a measure of size could be efficient. The code below evaluates <span class="math inline">\(\small \eqref{eq:n.pwr}\)</span> giving a <em>pps</em> sample of <span class="math inline">\(\small n = 57\)</span>, which will produce an anticipated <em>CV</em> of 0.149. In contrast, an <em>srs</em> of <span class="math inline">\(\small n = 82\)</span> would be necessary to obtain the same size <em>CV</em>.</li>
</ul>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">require</span>(PracTools)</span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="kw">data</span>(<span class="st">&quot;smho.N874&quot;</span>)</span>
<span id="cb7-3"><a href="#cb7-3"></a></span>
<span id="cb7-4"><a href="#cb7-4"></a>y &lt;-<span class="st"> </span>smho.N874[,<span class="st">&quot;EXPTOTAL&quot;</span>]</span>
<span id="cb7-5"><a href="#cb7-5"></a>x &lt;-<span class="st"> </span>smho.N874[, <span class="st">&quot;BEDS&quot;</span>]</span>
<span id="cb7-6"><a href="#cb7-6"></a>y &lt;-<span class="st"> </span>y[x<span class="op">&gt;</span><span class="dv">0</span>]</span>
<span id="cb7-7"><a href="#cb7-7"></a>x &lt;-<span class="st"> </span>x[x<span class="op">&gt;</span><span class="dv">0</span>]</span>
<span id="cb7-8"><a href="#cb7-8"></a>ybarU &lt;-<span class="st"> </span><span class="kw">mean</span>(y)</span>
<span id="cb7-9"><a href="#cb7-9"></a></span>
<span id="cb7-10"><a href="#cb7-10"></a>(N &lt;-<span class="st"> </span><span class="kw">length</span>(x))</span>
<span id="cb7-11"><a href="#cb7-11"></a><span class="co">#&gt; [1] 670</span></span>
<span id="cb7-12"><a href="#cb7-12"></a>CV0 &lt;-<span class="st"> </span><span class="fl">0.15</span></span>
<span id="cb7-13"><a href="#cb7-13"></a></span>
<span id="cb7-14"><a href="#cb7-14"></a>  <span class="co"># calculate V1 based on pp(x) sample</span></span>
<span id="cb7-15"><a href="#cb7-15"></a>pik &lt;-<span class="st"> </span>x<span class="op">/</span><span class="kw">sum</span>(x)</span>
<span id="cb7-16"><a href="#cb7-16"></a>T &lt;-<span class="st"> </span><span class="kw">sum</span>(y)</span>
<span id="cb7-17"><a href="#cb7-17"></a>(V1 &lt;-<span class="st"> </span><span class="kw">sum</span>( pik<span class="op">*</span>(y<span class="op">/</span>pik <span class="op">-</span><span class="st"> </span>T)<span class="op">^</span><span class="dv">2</span>))</span>
<span id="cb7-18"><a href="#cb7-18"></a><span class="co">#&gt; [1] 9.53703e+19</span></span>
<span id="cb7-19"><a href="#cb7-19"></a></span>
<span id="cb7-20"><a href="#cb7-20"></a>n &lt;-<span class="st"> </span>V1 <span class="op">/</span><span class="st"> </span>(N<span class="op">*</span>ybarU<span class="op">*</span>CV0)<span class="op">^</span><span class="dv">2</span></span>
<span id="cb7-21"><a href="#cb7-21"></a>(n &lt;-<span class="st"> </span><span class="kw">ceiling</span>(n))</span>
<span id="cb7-22"><a href="#cb7-22"></a><span class="co">#&gt; [1] 57</span></span>
<span id="cb7-23"><a href="#cb7-23"></a></span>
<span id="cb7-24"><a href="#cb7-24"></a>  <span class="co"># Anticipated SE for the pps sample</span></span>
<span id="cb7-25"><a href="#cb7-25"></a>(cv.pps &lt;-<span class="st"> </span><span class="kw">sqrt</span>(V1<span class="op">/</span>(N<span class="op">^</span><span class="dv">2</span><span class="op">*</span>n)) <span class="op">/</span><span class="st"> </span>ybarU)</span>
<span id="cb7-26"><a href="#cb7-26"></a><span class="co">#&gt; [1] 0.1495183</span></span>
<span id="cb7-27"><a href="#cb7-27"></a></span>
<span id="cb7-28"><a href="#cb7-28"></a>  <span class="co"># sample size for an srs to produce the same SE</span></span>
<span id="cb7-29"><a href="#cb7-29"></a><span class="kw">ceiling</span>(<span class="kw">nCont</span>(<span class="dt">CV0 =</span> cv.pps, <span class="dt">S2 =</span> <span class="kw">var</span>(y), <span class="dt">ybarU =</span> ybarU, <span class="dt">N =</span> N))</span>
<span id="cb7-30"><a href="#cb7-30"></a><span class="co">#&gt; [1] 82</span></span></code></pre></div>
<p>The <code>PracTools</code> package includes a variety of other functions relevant to the design of single-stage samples that are not discussed in this vignette:</p>
<table>
<colgroup>
<col width="45%"></col>
<col width="54%"></col>
</colgroup>
<thead>
<tr class="header">
<th align="left">Function</th>
<th align="left">Description</th>
</tr>
</thead>
<tbody>
<tr class="odd">
<td align="left"><img width="100/"></td>
<td align="left"><img width="500/"></td>
</tr>
<tr class="even">
<td align="left"><code>gammaFit</code></td>
<td align="left">Iteratively computes estimate of <span class="math inline">\(\small \gamma\)</span> in a model with <span class="math inline">\(\small E_M(y) = \mathbf{x}^T\boldsymbol{\beta}\)</span> and <span class="math inline">\(\small \sigma^2 \mathbf{x}^\gamma\)</span>. This is useful in determining a measure of size for <em>pps</em> sampling.</td>
</tr>
<tr class="odd">
<td align="left"><code>nDep2sam</code></td>
<td align="left">Compute a simple random sample size for estimating the difference in means when samples overlap</td>
</tr>
<tr class="even">
<td align="left"><code>nDomain</code></td>
<td align="left">Compute a simple random sample size using either a target coefficient of variation or target variance for an estimated mean or total for a domain</td>
</tr>
<tr class="odd">
<td align="left"><code>nLogOdds</code></td>
<td align="left">Calculate the simple random sample size for estimating a proportion using the log-odds transformation</td>
</tr>
<tr class="even">
<td align="left"><code>nProp</code></td>
<td align="left">Compute the simple random sample size for estimating a proportion based on different precision requirements</td>
</tr>
<tr class="odd">
<td align="left"><code>nProp2sam</code></td>
<td align="left">Compute a simple random sample size for estimating the difference in proportions when samples overlap</td>
</tr>
<tr class="even">
<td align="left"><code>nWilson</code></td>
<td align="left">Calculate a simple random sample size for estimating a proportion using the Wilson method</td>
</tr>
</tbody>
</table>
</div>
<div id="references" class="section level2 unnumbered">
<h2>References</h2>
<div id="refs" class="references">
<div id="ref-Cochran.77">
<p>Cochran, W. G. 1977. <em>Sampling Techniques</em>. New York: John Wiley &amp; Sons, Inc.</p>
</div>
<div id="ref-Lohr.99">
<p>Lohr, S. L. 1999. <em>Sampling: Design and Analysis</em>. Pacific Grove CA: Duxbury Press.</p>
</div>
<div id="ref-Rcore">
<p>R Core Team. 2020. <em>R: A Language and Environment for Statistical Computing</em>. Vienna, Austria: R Foundation for Statistical Computing. <a href="http://www.R-project.org/">http://www.R-project.org/</a>.</p>
</div>
<div id="ref-SSW.92">
<p>SÃ¤rndal, C.-E., B. Swensson, and J. Wretman. 1992. <em>Model Assisted Survey Sampling</em>. New York: Springer-Verlag.</p>
</div>
<div id="ref-Tille.2016">
<p>TillÃ©, Y., and A. Matei. 2016. <em>sampling: Survey Sampling, Version 2.8</em>. <a href="http://CRAN.R-project.org/package=sampling">http://CRAN.R-project.org/package=sampling</a>.</p>
</div>
<div id="ref-VDK.2018">
<p>Valliant, R., J. A. Dever, and F. Kreuter. 2018. <em>Practical Tools for Designing and Weighting Survey Samples</em>. 2nd ed. New York: Springer-Verlag.</p>
</div>
<div id="ref-Valliant.2019">
<p>Valliant, Richard, Jill A. Dever, and Frauke Kreuter. 2019. <em>PracTools: Tools for Designing and Weighting Survey Samples, Version 1.2.1</em>. <a href="https://CRAN.R-project.org/package=PracTools">https://CRAN.R-project.org/package=PracTools</a>.</p>
</div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
